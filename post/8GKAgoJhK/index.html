<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />

<title>常见问题 | 白日梦制造商</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />

<link
    rel="stylesheet"
    href="https://bemzhao.github.io/media/styles/all.css"
    integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr"
    crossorigin="anonymous"
/>
<link rel="shortcut icon" href="https://bemzhao.github.io/favicon.ico?v=1629869117127" />
<link rel="stylesheet" href="https://bemzhao.github.io/styles/main.css" />
<link rel="stylesheet" href="https://bemzhao.github.io/media/styles/monokai-sublime.min.css" />



<link rel="stylesheet" href="https://bemzhao.github.io/media/styles/aos.css" />
<script src="https://bemzhao.github.io/media/scripts/vue.js"></script>



<script src='https://bemzhao.github.io/media/scripts/Valine.min.js'></script>

        <meta name="description" content="v-model 原理
通过 v-bind 绑定 value 属性，v-on 监听触发 input 事件并传递数据，其底层是通过Object.defineProperty() 来劫持各个属性的 setter，getter，达到监听数据变动的目..." />
        <meta name="keywords" content="" />
    </head>
    <body>
        <div id="app" class="main">
            <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://bemzhao.github.io">
        <img src="https://bemzhao.github.io/images/avatar.png?v=1629869117127" class="site-logo">
        <h1 class="site-title">白日梦制造商</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/bemzhao" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
          <a class="social-link" href="https://twitter.com/bemzhao" target="_blank">
            <i class="fab fa-twitter"></i>
          </a>
        
      
        
          <a class="social-link" href="https://weibo.com/5270219385" target="_blank">
            <i class="fab fa-weibo"></i>
          </a>
        
      
        
      
        
      
    </div>
    <div class="site-description">
      面包会有的，牛奶会有的，一切都会有的
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/bemzhao" target="_blank">bemzhao</a> | <a class="rss" href="https://bemzhao.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


            <div class="main-container">
                <div class="content-container" data-aos="fade-up">
                    <div class="post-detail">
                        <h2 class="post-title">常见问题</h2>
                        <div class="post-date">2021-08-24</div>
                        
                        <div class="post-content" v-pre><h3 id="v-model-原理">v-model 原理</h3>
<p>通过 v-bind 绑定 value 属性，v-on 监听触发 input 事件并传递数据，其底层是通过Object.defineProperty() 来劫持各个属性的 setter，getter，达到监听数据变动的目的。</p>
<!-- more -->
<h3 id="nexttick-使用场景和原理">nextTick 使用场景和原理</h3>
<p>nextTick 中的回调是在下次 DOM 更新循环结束之后执行的延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。主要思路就是采用微任务优先的方式调用异步方法去执行 nextTick 包装的方法</p>
<h3 id="实现双向绑定的方法">实现双向绑定的方法</h3>
<p>① v-model<br>
② .sync 修饰符</p>
<pre><code>&lt;my-dialog :visible.sync=&quot;dialogVisible&quot; /&gt;

&lt;my-dialog
    :visible=&quot;dialogVisible&quot;
    @update:visible=&quot;newVisible =&gt; (dialogVisible = newVisible)&quot;
/&gt;

// my-dialog 组件在 visible 变化时 this.$emit('update:visible', newVisible) 即可。
</code></pre>
<p>③ model 属性，定制 prop 和 event<br>
④ vue-better-sync 插件</p>
<h3 id="vue-router-路由模式有几种">vue-router 路由模式有几种？</h3>
<p>① hash、② history、③ abstract</p>
<p>浏览器下默认为 hash 模式<br>
history 模式依赖 HTML5 History API 和服务器配置，主要利用了 history.pushState() 和 history.repalceState() 两个API<br>
abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式。</p>
<h3 id="导航守卫">导航守卫</h3>
<p>全局前置守卫：router.beforeEach((to, from, next) =&gt; {})<br>
全局后置钩子：router.afterEach((to, from) =&gt; {})<br>
路由独享的守卫：beforeEnter: (to, from, next) =&gt; {}<br>
组件内的守卫：<br>
①beforeRouteEnter(to, from, next) {}<br>
　不能获取组件实例 <code>this</code>，因为当守卫执行前，组件实例还没被创建，但是可以通过传一个回调给 next 来访问组件实例<br>
②beforeRouteUpdate(to, from, next) {}<br>
③beforeRouteLeave(to, from, next) {}</p>
<h3 id="vue-组件间通信有哪几种方式">Vue 组件间通信有哪几种方式？</h3>
<p>① props / <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>m</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">适</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">父</mi><mi mathvariant="normal">子</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">通</mi><mi mathvariant="normal">信</mi><mi mathvariant="normal">②</mi><mi>E</mi><mi>v</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>B</mi><mi>u</mi><mi>s</mi><mi mathvariant="normal">（</mi></mrow><annotation encoding="application/x-tex">emit 适用 父子组件通信
② EventBus （</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">适</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">父</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">信</span><span class="mord">②</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">（</span></span></span></span>emit / $on） 适用于 父子、隔代、兄弟组件通信<br>
③ provide / inject 适用于 隔代组件通信<br>
④ Vuex 适用于 父子、隔代、兄弟组件通信</p>
<h3 id="computed-和-watch-的区别和运用的场景">computed 和 watch 的区别和运用的场景？</h3>
<p>computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；<br>
场景：购物车结算</p>
<p>watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；<br>
场景：搜索框展示结果</p>
<h3 id="有哪些-vue-的性能优化">有哪些 Vue 的性能优化</h3>
<ul>
<li>对象层级不要过深，否则性能就会差</li>
<li>不需要响应式的数据不要放到 data 中（可以用 Object.freeze() 冻结数据）</li>
<li>v-if 和 v-show 区分使用场景</li>
<li>computed 和 watch 区分使用场景</li>
<li>v-for 遍历必须加 key，key 最好是 id 值，且避免同时使用 v-if</li>
<li>大数据列表和表格性能优化-虚拟列表/虚拟表格</li>
<li>防止内部泄漏，组件销毁后把全局变量和事件销毁</li>
<li>图片懒加载</li>
<li>路由懒加载</li>
<li>第三方插件的按需引入</li>
<li>适当采用 keep-alive 缓存组件</li>
<li>防抖、节流运用</li>
<li>服务端渲染 SSR or 预渲染</li>
</ul>
</div>
                         
                        <div class="next-post">
                            <div class="next">下一篇</div>
                            <a href="https://bemzhao.github.io/post/bzDWCkPw1/">
                                <h3 class="post-title">关于 Gridea 接入 Valine 评论系统</h3>
                            </a>
                        </div>
                         

                        <div id="vcomments" style="padding: 20px 0 0"></div>
                    </div>
                </div>
            </div>
        </div>

        <script src="https://bemzhao.github.io/media/scripts/aos.js"></script>
<script type="application/javascript">
    AOS.init();

    var app = new Vue({
        el: '#app',
        data: {
            menuVisible: false,
        },
    });

    app.$nextTick(() => {
        app.valine = new Valine({
            el: '#vcomments',
            appId: 'Ml09LvxW27MyF9u8NeA5TcoC-gzGzoHsz',
            appKey: 'SzTlDXgSGpUrrNC37WjCW1pV',
            visitor: true,
            placeholder: '评论留言',
        });
    });
</script>


<script src="https://bemzhao.github.io/media/scripts/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>
 

    </body>
</html>
